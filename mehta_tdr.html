<!DOCTYPE html>
<html>

<head>
	<meta name="description" content="3x3x3 Speedsolving Method - Mehta">
	<meta name="keywords" content="3x3, Rubik's cube, algorithm, method, Mehta">
  	<meta name="author" content="Yash Mehta">
	
	<title>Mehta</title>
	<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
    <header>
      <div class="container">
        <div id="branding">
            <h1><span class="highlight">Mehta</span></h1>
        </div>

        <nav>
          <ul>
            <li>
                <div class="dropdown">
                    <a class="primary" href="index.html">Home</a>
                </div>
            </li>
           
            <li>
                <div class="dropdown">
                    <a class="primary" href="EOLedge.html">EO-Ledge</a>
                </div>
            </li>
            
            <li class="current">
                <div class="dropdown">
                    <a class="primary" href="">Variants</a>
                    <div class="dropdown-content">
                        <a class="secondary" href="mehta_os.html">Mehta-OS</a>
                        <a class="secondary" href="mehta_tdr.html">Mehta-TDR</a>
                    </div>
                </div>
            </li>

            
                        
            <li>
                <div class="dropdown">
                    <a class="primary" href="examples.html">Examples</a>
                </div>
            </li>
            
            <li>
                <div class="dropdown">
                    <a class="primary" href="about.html">About</a>
                </div>
            </li>
          </ul>
        </nav>
      </div>
    </header>


    <section>
        <div class="container">
            <p>In the simplest terms, Mehta-TDR is to Mehta as ZB is to CFOP. Mehta-TDR solves the cube after EO-Ledge in 2 steps instead of 3, but at the cost of bumping up the algorithm count to almost 900. Compared to ZB, TDR is more efficient, has better recognition, and better algorithms and ergonomics. But since ZB itself hasn't made anywhere close to the top spots in cubing, this comparison doesn't achieve much.</p>

            <p>Getting a few abbreviations and definitions out of the way:</p>
            <ul>
                <li><b>TDR:</b> Trang's DR block; a ~10 STM algorithm which is usually RU-gen and occasionally RUD-gen, to solve the remaining 3 D-layer pieces on the 3x3x3 after EO-ledge, achieveing a pseudo-F2L state with EO done. It has 350 cases.</li> 
                <li><b>ZBLL:</b> Zborowski-Bruchem Last Layer; a ~15 STM algorithm to solve the last layer after EO and F2L (or pF2L) have been done. It has 493 cases.</li>
            </ul>

            <p>All of the TDR algorithms can be found <a href="https://docs.google.com/spreadsheets/d/1q5zlurWbYCpLzPpehkXrGQ0ab5Vy7n5dE6981ssuzNg/edit#gid=0">here</a>.
        </div>
    </section>

    <section id="rest">
    	<div class="container">
            <p>As of February 2021, the TDR algorithms have undergone a final screening to ensure they are speed-optimal, with most algorithms being RU and RUD. The movecount statistics (generated over 250,000 solves using the algorithm for each case as mentioned in the spreadsheet; hence note these are speed-optimal stats, not move-optimal) are given below:</p>

            <table>
                <thead>
                    <th>TDR variation</th>
                    <th>TDR (with pre-AUF)</th>
                    <th>ZBLL(with pre-AUF)</th>
                    <th>ABF</th>
                    <th>Total</th>
                </thead>
                <tr>
                    <td>Average</td>
                    <td>10.51</td>
                    <td>15.10</td>
                    <td>1.10</td>
                    <td>26.71</td>
                </tr>
                <tr>
                    <td>Std. Dev.</td>
                    <td>2.00</td>
                    <td>2.68</td>
                    <td>0.60</td>
                    <td>3.39</td>
                </tr>
                <tr>
                    <td>Median</td>
                    <td>10</td>
                    <td>15</td>
                    <td>1</td>
                    <td>27</td>
                </tr>
                <tr>
                    <td>Minimum</td>
                    <td>0</td>
                    <td>0</td>
                    <td>0</td>
                    <td>5</td>
                </tr>
                <tr>
                    <td>Maximum</td>
                    <td>16</td>
                    <td>22</td>
                    <td>2</td>
                    <td>38</td>
                </tr>
            </table>

            <p>Note that these are algorithmic steps, so the efficiency of the simulation is identical to the efficiency of any solver for each simulation. The average is under 27 moves for the finish, which is roughly equal to full Mehta-OS in theory, but there are many differences between the two approaches.</p>

            <p>First, being a 2-step finish instead of a 3-step finish allows for lesser points in the solve to pause for recognition. This is somewhat balanced out by the fact that the individual recognitions for Mehta-TDR are harder than the recognitions for Mehta-OS, and it is significantly harder to predict the case of the next step while doing an algorithm. Though, the recognition for the TDR step is easy enough to be predicted and even influenced during EOLE.</p>

            <p>Second, the sub-27 movecount for the Mehta-OS finish is done assuming a solver that always knows the best path, which may not always be the case. Thus, in practical solve situations, this movecount is bound to rise slighlty for Mehta-OS, but not for Mehta-TDR. Also, the average TPS for Mehta-TDR is likely to be faster than that for Mehta-OS after enough practice simply because the speed-optimal TDR and ZBLL algorithms are extremely finger-friendly.</p>

            <p>Finally, Mehta-TDR has very low likelihood of skips when no influencing is done (~0.1% chance to skip any step during a solve), while Mehta-OS has ~3.5% chance to skip one of the three steps, and ~0.1% chance to skip two of the three steps assuming no influencing. Also because it is relatively easier to influence Mehta-OS steps, it would be a better candidate for frequent fast singles.</p>

            <p>In all, the solves using the TDR variation are fairly straight-forward, allowing the user to focus on few specific things like recognition, TPS, and EO-Ledge efficiency. The TDR algorithms are almost all sub-1-able, some being even quicker; and it is possible to look-ahead to and influence the TDR case during EO-Ledge, minimising the pause before TDR. With sufficient advanced EO-ledge techniques, it is possible to achieve sub-45 average movecounts for this algorithm-based method, which in itself is a testament to the potential of this variant.</p>
    	</div>
    </section>
    

	<footer>
		<div class="container">
    		<p>For improvements or corrections, contact: yashovardhanmehta@gmail.com</p>
    	</div>
    </footer>
</body>
</html>
